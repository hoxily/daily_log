工作记录2016-10-18

检查了一下昨晚写的C代码。发现判定有bug。
原来又漏了break。果然加班的时候，效率不高啊。
我说怎么判死局效率有700倍之差。原来两者不一样呢。改过来之后，再试试。看看判死局效率如何。

试了下，构建真正的死局。这时用C#代码的暴力搜索20x10的棋局，需要4.17秒。
然而C代码搜20x10的死局，只需0.0065046秒

果然之前测试不准确的地方正是由于没有构建真正的死局。另外，C#代码中加入了太多的Debug.Log语句，有可能影响性能。试一试去掉，是什么效果。
我去，竟然真的是Debug.Log语句影响了速度。去掉之后，运行如飞。

然而我这种死局，不一定是让检测算法最耗时的死局。
诶，Debug.Log性能好坑啊。

基本上，去除了Debug.Log以后，性能与C代码插件的执行效率相当了。

我知道C代码为什么这么快了。是因为它没有干任何多余的事

OK。既然有了一个快速的死局判定方法。那么就可以考虑，死局的处理。
造成死局的一种情况是用户自己错误的消除步骤导致。如果重排，就是允许用户犯错。
例如：
AB
BA
BB
2x3的局。如果先消了第三行，那么就锁死了。
反过来说，如果允许无穷次重排，那么可以一直消下去。如此一来，考验的就是纯粹的眼力与手速了。
也许可以在出现死局时，进行时间上的惩罚。

遇到死局就直接随机重排，没问题。我知道重排的算法。问题是重排之后，恰巧又是一个死局呢？如果运气不好，就会反复重排，反复死局。最坏情况下就是，程序陷入了死循环。
完整局面强制非死局还好处理。因为每个卡牌的相邻的四边都有其他牌。强制凑相邻边即可。

哈哈，有了。不要使用随机重排，而是先找出所有的可能排列情况，然后随机地使用这些排列情况中的某一个。如果不行，再随机选择余下的排列情况中的另一个。直到所有的排列组合全部用尽。有可能会用尽却依然无解吗？
小心，8x8 的阶乘非常大！factorial(64)=126886932185884164103433389335161480802865516174545192198801894375214704230400000000000000
根本无法在内存中存储下来。

保留原始占用的格子不变，而只是重新排列这些格子里的卡牌，有没有可能出现枚举了所有的排列情况，都是死局呢？这是不可能的。证明如下：
任取其中一个排列，假设当前是死局情况。然后任取其中一张类型为A的牌A1。找到同为类型A的另一张牌A2。显然，这个时候，A1与A2不能相连。
这时，作分类讨论：
1。 A1，A2 在同一列或者同一行。显然，直连不通是因为被其他牌挡住了。设这条直线上从A1到A2的牌分别是A1,X1,X2,X3,...Xn,A2。那么把A1跟Xn做交换，或者把A2跟X1做交换，所得到的两种排列情况就不是死局；
2。A1，A2既不在同一行，也不在同一列。这个时候，一次转弯的直角线路不通是因为被其他牌挡住了。同理，设这个一次直角转弯上的卡牌分别是A1,X1,X2,...,Xn,A2。那么把A1与Xn做交换，就可以得到一次直角转弯的连接通路，或者直线连通的通路；

我想到一个随机重排强制非死局的算法了。
很简单，首先随机排列，然后应用上面证明中的构造通路的算法。

自己写的DebugUtility性能计数太烂。过多的Debug.Log输出耗费了太多的时间。时间上会相差成千上万倍。
赵国伟说Unity Editor有自带的性能统计函数。找找看。
找到了，https://docs.unity3d.com/ScriptReference/Profiler.BeginSample.html
using UnityEngine;
using System.Collections;

public class ExampleClass : MonoBehaviour {
    void Example() {
        Profiler.BeginSample("MyPieceOfCode");
        Profiler.EndSample();
    }
}