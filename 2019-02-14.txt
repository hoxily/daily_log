2019-02-14

逐片元操作过程。
片元->模板测试->深度测试->混合->颜色缓冲区。

模板测试的流程：

void 模板测试(片元)
{
    if (启用)
    {
        比较参考值（使用读取掩码）和已经存在于模板缓冲区中的模板值（使用读取掩码）；
        得到模板测试结果；
        if (通过模板测试)
        {
            根据状态设置更新模板缓冲区中的值（使用写入掩码）；
        }
        else
        {
            丢弃该片元；
        }
    }
}

深度测试的流程：

void 深度测试(片元)
{
    if (启用)
    {
        比较该片元的深度值和已经存在于深度缓冲区中的深度值；
        得到深度测试结果；
        if (!通过深度测试)
        {
            丢弃该片元；
            return;
        }
    }

    if (启用了深度写入)
    {
        将深度值写入深度缓冲区；
    }
}

模板测试(Stencil Test),
模板缓冲区(Stencil Buffer)，
模板测试通常用于限制渲染的区域。

深度测试(Depth Test),
透明效果和  深度测试以及深度写入  的关系非常密切。

渲染的过程是一个物体接着一个物体画到屏幕上的。而每人像素的颜色信息被存储在一个名为颜色缓冲区的地方。因此，当执行这次渲染时，颜色缓冲区中往往已经有了上次渲染的颜色结果，那么到底是使用这次渲染得到的颜色完全覆盖掉之前的结果，还是进行其他处理，这就是合并需要解决的问题。

混合(Blend)操作。

对于不透明物体，可以关闭混合操作。这样片元着色器计算得到的颜色值就会直接覆盖掉颜色缓冲区中的像素值。
对于半透明物体，需要使用混合操作来让这个物体看起来是透明的。

void 混合(片元)
{
    if (启用)
    {
        srcColor = 源颜色，即该片元的颜色值；
        dstColor = 目标颜色，即已经存在于颜色缓冲区中的颜色值；
        blendColor = 混合操作(srcColor, dstColor)；
    }
    else
    {
        blendColor = 源颜色，即该片元的颜色值；
    }

    更新颜色缓冲区中的值(blendColor);
}

Early-Z技术：将深度测试提前到片元着色器之前。

双重缓冲（Double Buffering）策略:对场景的渲染发生在后置缓冲（Back Buffer）中。一旦场景已经被渲染到了后置缓冲中，GPU就会交换后置缓冲区和前置缓冲区(Front Buffer)，而前置缓冲区是之前显示在屏幕上的图像。由此保证看到的图像总是连续完整的。

批处理（Batching），把小的DrawCall合并成一个大的DrawCall。
利用指处理，CPU在RAM中把多个网格合并成一个更大的网格，再发送给GPU。然后在一个DrawCall中渲染它们。但是批处理要求合并的网格使用同一种渲染状态。如果网格之前需要不同的渲染状态，那么就无法使用批处理技术。

什么叫渲染状态？


固定函数的流水线（Fixed-Function Pipeline),已过时。

Shader：
* GPU流水线上一些高度可编程的阶段。由着色器编译出来的代码会在GPU上运行；
* 有一些特定类型的着色器，如顶点着色器、片元着色器等；
* 依靠着色器可以控制流水线中的渲染细节，例如使用顶点着色器进行顶点变换以及传递数据，使用片元着色器进行逐像素的渲染。

----
//Shader后跟的双引号内是该Shader的名字，可以使用斜线进行分类。
/*除了双斜线的单行注释，还可以
使用这样子的块注释。*/
Shader "Path/To/ShaderName"
{
    //属性列表，将会在材质的Inspector面板列出，方便调整属性值。
    Properties
    {
        //下面演示了Int类型的属性的定义方式。
        //名字通常以下划线开头。
        //等号后面定义了默认值。
        _NameOfIntType ("展示在Inspector面板的名字", Int) = 1
        //无取值范围
        _NameOfFloatType ("Float", Float) = 3.14
        //限定了取值范围,从0.0到1.0
        _NameOfRangeType ("Range", Range(0.0, 1.0)) = 0.5
        //RGBA颜色
        _NameOfColorType ("Color", Color) = (1, 1, 1, 1)
        //(x,y,z,w)四维向量
        _NameOfVector ("Vector", Vector) = (1, 2, 3, 4)
        //2D纹理
        _NameOf2D ("2D", 2D) = "white" {}
        //Cube纹理
        _NameOfCube ("Cube", Cube) = "black" {}
        //3D纹理
        _NameOf3D ("3D", 3D) = "gray" {}
    }
}

----

章节4.2.3对二维坐标系与三维坐标系的对比中，说所有的二维笛卡尔坐标系都是等价的，我不认同。所谓的把整个纸面水平翻转一下，这个操作既不是平移，也不是旋转，而是一个镜像操作。
同样的，三维的左手坐标系可以通过平移、旋转加镜像变为三维的右手坐标系。

把纸面水平翻转这个操作已经突破了2D平面，这是在3D上做的旋转。

那么可以设想存在一种在4D空间沿着某个面的“旋转”操作，把三维左手坐标系翻转为三维右手坐标系。

从这个角度来理解，镜像翻转的本质是在更高一维度下进行的旋转操作。
如果真的有四维空间，有一个三维物体进入四维空间随意地旋转，重回三维空间时就可能变成原来的镜像！