2019年07月23日, 星期二, GPS(30.3107, 120.0907)

使用ListView时受到的诸多限制，都是由于虚拟的视图导致的。DataModel的数量与实际实例化出来的Item数量不符。

即便使用记录ListItemView对象的方法，来标记当前哪一个处于选中状态，受虚拟视图的影响，上下滚动后，之前记录的ListItemView对象已经被回收重用了。这时直接修改记录的ListItemView对象就用错对象了。

所以需要遵守第一个原则，即总是通过改变Model数据，再强制刷新ListView来将最新的Model数据表现到视图上。

之前遇到一个FabricModel被多处ListView使用的情况。而为了遵守上述第一条原则，在原始的FabricModel里追加了“ui_”开头的字段，用于表达UI的状态以及UI控件的点击事件回调。这时就GG了。不仅两个ListView的选中状态会发生混乱，关键的UI点击事件还会执行错误的回调。

针对这种情况，需要引入第二个原则，即每个ListView需要维持一个独立的ListItemData列表，列表中的元素是原始Model的定制化结果。

除了以上的2个原则，还有一个受内存限制而产生的原则。不管是原始Model还是ListItemData对象，都是很小的内存占用量。而ListView视图会要求展示Model对应的缩略图等比较占内存的东西。这时如果把缩略图也丢进Model或者ListItemData里，就很容易发生内存溢出。除了要展示列表项的缩略图，还出现过要求获取当前点击项的漫反射纹理缩略图的要求。同样的，这些缩略纹理只能绑定在ListItemView上，随着ListItemView激活而加载，随着ListItemView的回收而断开引用。因为是虚拟的ListView，所以全部实例ListItemView的数量是有限少的，也就不会出现内存溢出的问题。总结一下，就是出现大内存占用的对象时，不要放到Model里，也不要放到ListItemData里，尽量作为成临时的对象，绑定到ListItemView上，随着SetData和OnRecycle而加载和卸载，结合对象池来提高性能。
