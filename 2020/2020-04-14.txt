2020年04月14日，星期二，杭州，多云转阴，11~21摄氏度

由于实际上单个Product并不能处理事件，所以实际上是交给ProductManager级别的上级处理的。所以在事实上，事件的响应者是Manager。

对于事件分发，有如下一个例子：
一个OnPointerDown事件，首先被拿去检测最微小的、优先级更高的、嵌套层级更深的事物。比如印绣花。假如有一个印绣花Manager，它就能结合当前的TAB打开状态，根据当前已经存在的印绣花，使用射线检测，判定出是否选中了某个印绣花。

在随后的OnPointerUp之前的Update检测中，检查到指针发生了移动，就可以判定为拖动印绣花。

假如射线检测并没有检测到印绣花或者Tab打开状态不符合条件，就会直接忽略该事件。

对于UI事件分发和逻辑控制的那个Manager，就会将事件交给上层Manager处理。

----

查看libwebgl的代码会发现，在Lt3D类里，OnXXX事件会根据各种状态进行事件分发。但是有一个特例，就是LtOrbitControl，是通过enabled属性来控制，而LtOrbitControl内部则是自行注册DomElement的各种事件监听器。

----

遇到一个非常难的问题。上级要求给出一个Unity端升级时间表。然而在尝试抄libwebgl的代码进行重写的过程中发现写不动。上级并不在乎Unity的内部代码是什么。既然完全重构暂时做不到，是否要换个思路，从修改现有的ThreeD代码来入手呢？

到底是什么东西阻碍我继续写下去？

----

华晋航让我把遇到的困难列一下。但是思维混乱的我，感觉连困难点也列不出来。虽然对接的时候，使用了ThreeD模块的暴露的方法，但是其实对它里面的核心是一抹黑？
