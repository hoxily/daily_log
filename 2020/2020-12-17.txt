2020年12月17日，星期四，杭州

在百度首页打开DevTools，可以在Console里看到它们的招聘广告。里面的宣传文字好像更新了，成了现在这段：
“
每一个星球都有一个驱动核心，
每一种思想都有影响力的种子。
感受世界的温度，
年轻的你也能成为改变世界的动力，
百度珍惜你所有的潜力。
你的潜力，是改变世界的动力！
”

查看GLSL函数手册，比如 https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/clamp.xhtml 这里的clamp函数，总是会遇到奇奇怪怪的参数类型：genType, genIType, genUType, genDType。

其实在GLSLangSpec 4.40里的第8章 Built-in Functions有解释。

float, vec2, vec3, vec4 统一用 genType 代替；
int, ivec2, ivec3, ivec4 统一用 genIType 代替；
uint, uvec2, uvec3, uvec4 统一用 genUType 代替；
bool, bvec2, bvec3, bvec4 统一用 genBType 代替；
double, dvec2, dvec3, dvec4 统一用 genDType 代替；

另外，mat 对应于任意维度的单精度矩阵；dmat 对应于任意维度双精度矩阵。

----

折腾了一下在现有的lib_webgl项目上，针对baseColor类型的纹理，遇到png时仅变换到预乘alpha状态，而不还原回非预乘alpha状态，直接在shader里处理。

昨天已经试过了除以alpha分量来还原rgb分量，但是会出现神奇的白边。从原理上证明了，若想要进行PBR光照计算，只能将预乘alpha的纹理颜色还原回非预乘状态。

今天抛开还原的问题。仅针对找到的PMA介绍文章里的Blend公式做验证。也就是正常的
color = Src_rgb * Src_a + Dst_rgb * (1 - Src_a)
模式，因为纹理已经乘上了Src_a，所以Blend公式变成如下所示的计算过程：
color = Src_rgb + Dst_rgb * (1 - Src_a)

只需修改Style3DDecalMaterial构造函数，添加如下参数：
blendDst: THREE.OneMinusSrcAlphaFactor,
blendSrc: THREE.OneFactor,
blending: THREE.CustomBlending // 必需要设置blending为CustomBlending，才能使上面的这两项生效。

测试结果很奇怪依然有白边。找到很久，发现canvas画出的framebuffer变得透明了，透出来了canvas所在的div的background-color（也就是白色）。
于是又添加了两个控制Alpha的Blend系数：
blendDstAlpha: THREE.OneFactor,
blendSrcAlpha: THREE.ZeroFactor，
这两个系数的意图是让印花底下的面料写入的alpha保持为原先的1.0，然后印花片元输出的alpha乘上0相当于忽略掉。
但是结果还是很奇怪，出现了白边。还有更加神奇的地方。当把这个叠在面料上会出现白边的印花，拖到另一个印花上时，会发现边缘的白边接近消失。就像是已经画过一遍印花的地方，不会再透出白色来一样。
