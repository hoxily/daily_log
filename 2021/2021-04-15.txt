2021年04月15日，星期四，杭州

昨天晚上看半天代码，没有思路。今天早上来突然就找到了灵感。过程是这样的。

明线本身显示得很小，如果用放大功能，则镜头直接穿模看不到明线。突然灵感一闪，使用放大镜功能查看明线。这时可以看到白色明线周围一圈淡淡的替换颜色！这说明换色逻辑的代码确实执行了，只是换色效果不好。很久之前在脑里有过的念头：半透明的纹理图，其平均颜色应该如何定义？结合这个换色效果不好的表现，以及之前PMA纹理缩放的经验积累，显然又是跟alpha分量有关。

总结一下就是，对原始纹理求平均颜色时应该要考虑到alpha分量，利用alpha分量来做加权平均。

考虑这样一种情况：一个白色的明线纹理图，周围都是半透明或全透明的像素。从像素占比上来看，明线像素数远少于周围的透明像素。如果不考虑alpha分量，直接求各通道的平均值，那么周围透明像素的RGB分量就混入了最终结果。平台使用的aliyun OSS缩放，会自动将全透明像素RGB置为(0,0,0)，相当于求到的平均值都是接近黑色的颜色。这样一来，换色算法只能将明线周围的灰黑色像素换成指定色，主体的白色没有换掉。

除去这个求平均颜色算法本身的bug，另一个bug则是由于originMainTextureColorBlendMode没有重置为null引起的。导致loadUserProduct后，直接去换色没有走ColorBlendMode.Color模式，还是用的老的Multiply模式。

由这两个bug相结合，最终表现出来的结果就是，刚从userproduct加载的款式，可以正常切换明线的颜色。但是一旦Clear换色，再去应用换色，就会走Color模式，由于只在明线周围一圈淡淡的颜色，误以为换色失效了。
